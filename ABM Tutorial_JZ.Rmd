---
title: 'R Agent Based Model for Infectious Diesease Tutorial'
subtitle: 
author: "Jasper Zhang"
output:
  html_document: default
  pdf_document: default
---

-   Jasper Zhang, MSc
-   Petros Pechlivanoglou, PhD


Please acknowledge our work. See details to cite below.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = TRUE)
options(scipen = 999)  # disable scientific notation
rm(list = ls())        # clear memory (removes all the variables from the workspace)
```

Change `eval` to `TRUE` if you want to knit this document.

# 01 Load packages

```{r}
if (!require('pacman')) install.packages('pacman'); library(pacman) 
# load (install if required) packages from CRAN
p_load("devtools", "dplyr", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "markdown", "stringr", "dampack", "matrixStats")
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) # Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# negate function
`%!in%`                      <- Negate(`%in%`)


# Calculate the infection probability by every cycle, assuming the probability increases by number exposures
fun_infect_prob <- function(p_infect, n_exposure) { 
  # Arguments:
  # p_prob:     the probability of infection in one time contact
  # n_exposure: the time of being exposed to infectious individuals
  # Returns: 
  # the probability of being infected based on certain exposure time
  
  return(1 - (1 - p_infect) ^ (n_exposure))   # 1 - prob is the prob of being safe
}
```


In this basic ABM we assume that individuals can be be in one of 5 states:  1. susceptible to an infection, 2.infected and infectious but not in quarantine, 3.infected in quarantine, 4. recovered. Recovery is assumed to be a saturating state. We assumed that the quarantine period is 14 days from infection for all infected individuals. We further assumed that for the first day of the disease individuals are infectious although asymptomatic, and that as soon as there are symptoms individuals will self-quarantine. We further assumed perfect adherence to quarantine protocols. 
We developed a agent based model where we assumed a daily cycle length. We modelled a hypothetical environment where indiciduals will go to work and can be infected at work and in the community but cannot infect others at home. We used the model to prospectively estimate a 60 day period. We assumed a latency of 4 days from acquiring the infection until symptom development.



# 03 Model input

## 03.1 Define model input parameters

```{r}
## General setups
set.seed(1)                                             # set the seed 

n_cycles                 <- 100                         # number of cycles
n_i                      <- 10000                       # number of individuals

t_iso_max                <- 14                          # quarantine period
t_latent                 <- 4                           # incubation period: time from receiving virus to being infectious
t_detect                 <- 9                           # becoming infectious to isolation
t_recover                <- 14                          # days to recover from being infected


# the 5 health states of the model:
v_names_states           <- c("S",                      # Susceptble 
                              "SQ",                     # Susceptble quarantine 
                              "I",                      # Infected
                              "IQ",                     # Infected quarantine
                              "R")                      # Recovered      

v_names_cycles           <- paste("cycle", 0:n_cycles)  # cycle names
n_states                 <- length(v_names_states)      # number of health states 


#Transition probabilities

#infection probabilities vary by location

# community
p_TransmitCommunity      <- 0.08                        # daily community transmission probability 

# atwork 
p_TransmitWork           <- 0.02                        # daily at work transmission probability per interaction

# Determine the initial number of 'S' (susceptible) and 'I' (infected) agents based on seed ratio
p_seed_ratio             <- 0.3                         # proportion of seed infected agents when initializing the simulation population  
n_S                      <- round((1 - p_seed_ratio) 
                                     * n_i)             # number of initialized susceptible agents
n_I                      <- n_i - n_S                   # number of initialized infected agents


# workplace characteristics 
v_workplace_size           <- c(5, 6, 7)                  # we assume workplaces with sizes of 5 to 7 people


```


# 04 Sample individual level characteristics

## 04.1 Static characteristics

```{r}
# Initialize a population dataframe for an agent-based model

age_mean                 <- 40
age_sd                   <- 10
p_male                   <- 0.5
age_lim                  <- 18

# Create agent matrix
df_X <- data.frame(
  pid = 1:n_i,                                          # Assign individual IDs
  Sex = sample(x = c("Female", "Male"),                 # Random gender assignment
                prob = c(p_male,1 - p_male), 
                size = n_i, replace = TRUE),           
  Age = round(rnorm(n_i,                                # Age drawn from a normal distribution
                    mean = age_mean,
                    sd = age_sd),
              digits = 0)                     
)


# Randomly assign initial states to agents
df_X$state <- sample(c(rep("S", n_S), rep("I", n_I)))

# Ensure Age variable has only  values over a predefined limit
df_X$Age[df_X$Age < age_lim] <- age_lim # only adults

# Define workplace structure and IDs
p_workplace_size <- v_workplace_size / sum(v_workplace_size)
n_workplace <- floor(n_i * p_workplace_size / v_workplace_size)[1]
v_work_id <- c(
  rep(1:n_workplace, each = v_workplace_size[1]),
  rep((n_workplace + 1):(n_workplace  * 2), each = v_workplace_size[2]),
  rep((n_workplace * 2 + 1):(n_workplace * 3), each = v_workplace_size[3])
)

n_remain                 <- n_i - length(work_id)
v_more_workid            <- c()
wid_new                  <- max(work_id) + 1
while(n_remain !=0){
  n_wid_new  <- ifelse(n_remain > min(v_workplace_size), min(v_workplace_size), n_remain)
  v_more_workid <- c(v_more_workid, rep(wid_new, n_wid_new))
  n_remain <- n_remain - n_wid_new
  wid_new <- wid_new + 1
}

v_work_id                <- sample(c(v_work_id,v_more_workid))
df_X$wid                 <- v_work_id                    # Workplace ID


# Initialize other agent attributes
df_X <- df_X %>%
  mutate(
    n_exposure <-  0,                                     # Exposure level
    n_contact <-  0,                                      # Number of contacts in a day
    v_Ts <-  0,                                           # Time since being infected
    t_iso = 0                                             # Quarantine time clock
  )

# Set the number of contacts at work based on workplace size
n_worksize               <- as.matrix(table(v_work_id))[v_work_id]   # Calculate Workplace size
df_X$n_worksize          <- n_worksize                               # Add Workplace size for each agent
df_X$n_contact           <- sapply(n_worksize,
                                   function(x) sample(0:(x - 1), 1)) # Randomly assign contact number
```


# 05 Define Simulation Functions

## 05.1 Probability function

The `Probs` function updates the transition probabilities of every cycle is shown below.

```{r}
Probs <- function(df_X) { 
  # Arguments:
  # df_X: data frame with individual characteristics data 
  # Returns: 
  # transition probabilities for that cycle
  
  # create matrix of state transition probabilities
  m_p_t                  <- matrix(0, nrow = n_states, ncol = n_i)
  M_t                    <- df_X$state                    # M_t:  health state occupied at cycle t (character variable)
  # give the state names to the rows
  rownames(m_p_t)        <- v_names_states                         
  
  #Calculate the probability of being infected for susceptible people
  df_X_sus               <- df_X[M_t  == "S",].           # identify those susceptible
  
  p_infect_prob          <- fun_infect_prob(p_TransmitWork, df_X_sus$n_exposure)
  
  p_Sus_Inf              <- (1- ((1-  p_TransmitCommunity ) *
                                   (1 - p_sus)))          # p_work_infect  1 minus the prob of being safe all day

  #Calculate the probability of being infected for susceptible quarantine
  
  #susceptible 
  m_p_t["S"     , M_t == "S"]        <- 1 - p_Sus_Inf     # Prob: stay in S state
  m_p_t["I"     , M_t == "S"]        <- p_Sus_Inf         # Prob: transit from S to I
  
  return(m_p_t)
}  


```

## 05.2 Quanrantine Function

```{r}

#make pop the only people in quarantine SQ + IQ


#Quarantine_Check can update the quarantine clock at current time cycle
Quarantine_Check <- function(df_pop){
  # Arguments:
  # pop: population dataframe of current time cycle t
  # pre_state: states at previously cycle t-1
  # Returns: 
  # new population dataframe with updated states
  
  # -------------------------------------
  # Step1: find people in different quarantine conditions
  # -------------------------------------
  
  # People in quarantine:
  
  # we dont have people infetect in quarantine
  # 
  # # condition 1: reset quarantine clock for those who become infected or have close contact with infected people during quarantine
  # new_infected_in_Q          = which(pop$state %in% infect_states_iso & pre_state == "SQ") #got infected in quarantine
  # 
  # reset_workplace            = unique(pop$wid[new_infected_in_Q])
  # reset_people               = pop$wid %in% reset_workplace #find all the people who had expose in workplace quarantine
  # 
  
  # condition 2: find people are going to be released from quarantine
  # check if quarantine clock hit t_iso_max
  full_q      <- df_pop$t_iso == t_iso_max # & pop$state != "R" # & !reset_people # if you've been recovered you are exempt from quarantine only do quarantine once.
  
  #find susceptible people and infected people who meet quarantine time
  sus_full_q  <- full_q & df_pop$state == "SQ"
  inf_full_q  <- full_q & df_pop$state == "IQ"
  
  # condition 3: find people who stay in quarantine and the quarantine clock has to be incremented.
  # else_q                     = # !full_q            #pop$t_iso < t_iso_max # & pop$t_iso >0) #& !reset_people & pop$state != "R"  
  
  # Other people:
  # condition 4: find newly infected people entering quarantine NOTE: people enter quarantine by detection
  new_infected               = which(df_pop$v_ti == t_detect ) #new infected generated from infected
  
  # condition t_iso_max: find newly infected people's dependencies in families and workpalces
  new_infected_workplace     = unique(df_pop$wid[new_infected]) #families have newly infected in quarantine cases
  
  #new_infected_work= unique(pop$wid[new_infected]) #workplaces have newly infected in quarantine cases #comment out if same workplace contact don't need to be put in quarantine
  
  new_qurantine   <- ((df_pop$wid %in% new_infected_workplace & df_pop$t_iso == 0) ) #people whose quarantine clocks have to be set to 1 including
  new_qurantine_add <- new_qurantine & pop$state %!in% iso_states #find people need to be put in quarantine state
  
  
  # -------------------------------------
  # Step2: Update quarantine clock
  # -------------------------------------
  
  # set new_quarantine clock to 1 
  pop$t_iso[new_qurantine]    = 1
  pop$state[new_qurantine_add] = paste(pop$state[new_qurantine_add],"Q",sep = "") #update quarantine states
  pop$time[new_qurantine]     = pop$time[new_qurantine]+1 #increment total quarantine time
  
  
  # release people with meet t_iso_max-days quarantine requirement
  # - isolated susceptible people will go to susceptible
  # - infected people will go to recovered
  pop$t_iso[full_q]           =  0
  pop$state[sus_full_q]       = "S" #when quarantine ends, state goes back to susceptible
  pop$state[inf_full_q]       = "R" #when quarantine ends, state goes back to recovered
  
  #increment quarantine clock and total quarantine time for everyone else in quarantine
  pop$t_iso[else_q]           = pop$t_iso[else_q] + 1
  pop$time[else_q]            = pop$time[else_q] + 1
  return (pop)
}

```

## 05.3 Exposure at work

```{r}

# Exposure_Check calculates the exposure of workers at their workplace
fun_work_exposure <- function(pop) {
  
  # Arguments:
  # pop: A data frame representing the entire population. It should contain columns such as 'atwork', 'expl', 
  #      'state', 'wid', 'pid', and others that are relevant to the exposure at work.
  # Returns:
  # A modified version of the 'pop' data frame with updated exposure levels ('expl') and possibly other columns 
  # based on interactions at the workplace.

  
  # -------------------------------------
  # Step1: Initialize and filter worker population
  # -------------------------------------
  allpop <- pop                                                                 # Extract entire population data
  worker_list <- pop[pop$atwork == 1,]                                          # Filter workers currently at work
  
  # Check if there are workers present
  if (sum(pop$atwork == 1) > 0) {
    select_pop <- allpop[pop$atwork == 1,]
    expl_list <- select_pop$n_exposure
    infectious <- select_pop$state %in% infect_states                           # Identify infectious individuals
    wid_list <- select_pop$wid                                                  # List of workplace IDs
    out_of_iso <- select_pop$state %!in% iso_states                             # Workers out of isolation
    pid_list <- select_pop$pid[out_of_iso & select_pop$state == "S"]          # Susceptible workers out of isolation
    
    # -------------------------------------
    # Step2: Build the workplace table
    # -------------------------------------
    workplacetable <- data.frame(table(wid_list[select_pop$atwork == 1]))
    names(workplacetable) <- c("wid", "wsize")
    
    inf_worker <- select_pop[infectious,]                                       # Filter infectious workers
    inf_workplace <- inf_worker$wid                                             # List of workplaces with infectious workers
    
    # Check if there are infectious workers present
    if (nrow(inf_worker) > 0) {
      contact <- c()
      
      # -------------------------------------
      # Step3: Identify contacts for infectious workers
      # -------------------------------------
      for (i in 1:nrow(inf_worker)) {
        select_worker <- inf_worker[i,]
        workplacepid <- select_pop[select_pop$wid == select_worker$wid,]$pid  # Fetch workers at the same workplace
        to_contact <- workplacepid[!workplacepid %in% select_worker$pid]     # Exclude the current worker
        
        # Determine contacts based on the contact number
        if (length(to_contact) > 1) {
          new_contact <- sample(to_contact, min(length(to_contact), select_worker$n_contact))
          contact <- c(contact, new_contact)
        } else if (length(to_contact) == 1) {
          contact <- c(contact, to_contact)
        }
      }
      
      # -------------------------------------
      # Step4: Build the contact table
      # -------------------------------------
      if (length(contact) != 0) {
        contact_table <- data.frame(table(contact))
        names(contact_table) <- c("pid", "expl")
        
        # Convert to numeric types
        contact_table$pid <- as.numeric(as.character(contact_table$pid))
        contact_table$n_exposure <- as.numeric(as.character(contact_table$n_exposure))
        
        # Update exposure levels
        expl_list[select_pop$pid %in% contact_table$pid] <- expl_list[select_pop$pid %in% contact_table$pid] + contact_table$n_exposure
        allpop[allpop$pid %in% contact_table$pid,]$contact_type <- 3
      }
    }
    
    # Update the main population dataset
    allpop[pop$atwork == 1,]$n_exposure <- expl_list
  }
  
  return(allpop)
}



```

## 05.4 Detection function

The `Detection` function detec infected people

```{r}
Detection <- function(pop, v_TS){
  
  # Arguments:
  # pop: A data frame representing the entire population with individual's current health states and other relevant information.
  # v_TS: A vector representing time since onset of illness for each individual in 'pop'.
  # Returns:
  # A modified version of the 'pop' data frame with updated states for detected individuals, especially indicating those under quarantine.
  
  # Detect individuals infected for 9 days
  detected_individuals = (v_TS == t_detect) & pop$state == "I"  # we dont' need pop$t_detect
  
  # if the state is I, and the time is 9 
  
  # Update state of newly detected individuals not in isolation states to include quarantine ("Q")
  new_iso = detected_individuals & pop$state %!in% iso_states
  pop$state[new_iso] = paste(pop$state[new_iso], "Q", sep = "") #  IQ is infected 
  

  
  return(pop)
}



```


## 05.5 Microsimulation function

Below we develop the microsimulation function that allows the model to be run.

```{r}
# `MicroSim` is a microsimulation function to model individual-level disease progression and transmission.
MicroSim <- function(df_X, seed = 1, n_cycles = 10) {
  
  # Arguments:  
  # df_X: A data frame containing individual-level data.
  # seed: Seed for the random number generator; default is 1.
  # n_cycles: Number of cycles or iterations to simulate; default is 10.

  # Ensures reproducibility of results.
  set.seed(seed)

  # Determine the number of individuals in the dataset.
  n_i = nrow(df_X)
  
  # Initialization of matrices to store:
  # m_M: health state information over time for every individual.
  # m_Ts: track the number of days since an individual got infected.
  # m_exposure: track exposure levels for individuals.
  # Each matrix has rows corresponding to individuals and columns corresponding to days.
  
  m_M <- matrix(nrow = n_i, ncol = n_cycles + 1, 
                dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                paste("cycle", 0:n_cycles, sep = " "))) 
  m_Ts <- matrix(nrow = n_i, ncol = n_cycles + 1, 
                  dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                  paste("cycle", 0:n_cycles, sep = " ")))
  m_exposure <- matrix(nrow = n_i, ncol = n_cycles, 
                   dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                   paste("cycle", 1:n_cycles, sep = " ")))

  # Set initial health state and time since illness onset for each individual.
  m_M[, 1] <- df_X$state
  m_Ts[,1] <- df_X$v_Ts
  
  v_Ts <- df_X$v_Ts    
  v_inf <- rep(0, n_i)

  # Initialize vectors to store daily counts of total infections, new infections, and detected cases.
  v_total_inf_daily <- rep(0,n_cycles)
  v_new_inf_daily <- rep(0,n_cycles)
  v_detected_daily <- rep(0,n_cycles)
  
  # Simulation loop for each day.
  for (t in 1:n_cycles) {
    
    # Reset exposure and contact type levels for each individual.
    df_X$n_exposure <- 0

    # Calculate exposure at work for each individual.
    df_X <- work_exposure(df_X)
    m_exposure[,t] <- df_X$n_exposure
    
    # Calculate transition probabilities based on current health state and exposure.
    m_P <- Probs(df_X)

    # Validate transition probabilities.
    check_transition_probability(m_P, verbose = TRUE)
    check_sum_of_transition_array(m_P, n_rows = n_i, n_cycles = n_cycles, verbose = TRUE)
    
    # Generate new health states based on the calculated transition probabilities.
    prob_new_state = samplev(m_P)
    df_X$state = prob_new_state
    df_X = Detection(df_X,v_Ts)
    prob_new_state = df_X$state
    
    # Update vectors with new infection, total infection, and detection counts.
    v_detected_daily[t] =  sum((v_Ts == df_X$t_detect) & prob_new_state != "R")
    v_total_inf_daily[t] = sum(prob_new_state %in% all_infect_states)
    v_new_inf_daily[t] = sum((m_M[, t] %in% sus_states   & prob_new_state %in% all_infect_states ))

    # Update quarantine status based on previous day's state and current state.
    df_X = Quarantine_Check(df_X,m_M[, t])
    qc_state = df_X$state

    # Update the time since illness onset for next day.
    v_Ts <- if_else(qc_state %in% all_infect_states, v_Ts + 1, 0)
    m_Ts[,t + 1] = v_Ts

    # Update individuals who have reached recovery time to 'R' state.
    v_go_to_recover <- if_else(v_Ts >= t_recover, TRUE, FALSE)
    df_X$state[v_go_to_recover] = "R"
    
    # Store current state for each individual for the next day.
    m_M[, t + 1] <- df_X$state

    # Display simulation progress at every 10% completion.
    if(t/(n_cycles/10) == round(t/(n_cycles/10), 0)) {
      cat('\r', paste(t/n_cycles * 100, "% done", sep = " "))
    }
  }

  # Store results from the simulation in a list.
  results <- list(m_M = m_M, pop = df_X, v_new_inf_daily = v_new_inf_daily, 
                  v_total_inf_daily = v_total_inf_daily, v_detected_daily = v_detected_daily)

  # Return the results.
  return(results)

} # End of `MicroSim` function

```

## 06 Run Microsimulation

```{r, eval = TRUE, echo = TRUE, warning = FALSE, message = FALSE, results = FALSE }
# 06 Run Microsimulation
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# Run the simulation model
outcomes <- MicroSim(df_X = df_X, seed = 1,n_cycles = n_cycles)
```

# 07 Visualize results to be updated

```{r}
# First, we'll need the ggplot2 library to create the visualizations.
library(ggplot2)

# -------------------------------------
# Step 1: Data Preparation
# -------------------------------------

# Create a data frame to hold the results for visualization. 
# Here, we take the number of cycles (days) and the respective outcomes for daily new infections, 
# cumulative infections, and daily detections.
df <- data.frame(
  day = 1:n_cycles,                             # Days from 1 to the end of the simulation
  new_inf_daily = outcomes$v_new_inf_daily,     # Daily new infections
  total_inf_daily = outcomes$v_total_inf_daily, # Cumulative daily infections
  detected_daily = outcomes$v_detected_daily    # Daily detected cases
)

# -------------------------------------
# Step 2: Data Visualization
# -------------------------------------

# Using ggplot, we'll plot the daily new infections, cumulative infections, and detected cases.
p <- ggplot(df, aes(x = day)) +                 # Define the x-axis as the 'day'

  # Plot daily new infections
  geom_line(aes(y = new_inf_daily, color = "New Infections Daily"), size = 1) +

  # Plot cumulative infections
  geom_line(aes(y = total_inf_daily, color = "Total Infections Daily"), size = 1) +

  # Plot daily detected cases
  geom_line(aes(y = detected_daily, color = "Detected Daily"), size = 1) +

  # Add labels and title to the plot
  labs(
    title = paste0("Daily Cases Over ",n_cycles," Days"),       # Title of the plot
    x = "Day",                                 # Label for the x-axis
    y = "Number of Cases",                      # Label for the y-axis
    color = "Legend"                            # Legend title
  ) +

  # Customize the colors for each line in the plot
  scale_color_manual(values = c("New Infections Daily" = "blue", 
                                "Total Infections Daily" = "darkgreen",
                                "Detected Daily" = "red")) +

  # Use a minimal theme for a clean look
  theme_minimal() +

  # Position the legend at the bottom of the plot
  theme(legend.position = "bottom")

# Display the generated plot
p

# -------------------------------------
# Step 3: Save the Visualization
# -------------------------------------

# Save the plot as a PNG image. The DPI determines the resolution, and width and height determine the size.
ggsave("daily_cases_plot.png", p, dpi = 300, width = 10, height = 8, units = "in", device = "png")

```


We kindly request you to add the following Acknowledgement paragraph to your further work where DARTH code formed the basis. We also like to remind you that you can add other sources of reference to this paragraph to acknowledge code you got from others.

# Acknowlegdement

For this work we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention: Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 1329--1339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

Other work from DARTH can be found on the website: <http://darthworkgroup.com/publications/>

# Copyright for assignment work

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.All rights reserved in Canada, the United States and worldwide. Copyright, trademarks, trade names and any and all associated intellectual property are exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating institutions. These materials may be used, reproduced, modified, distributed and adapted with proper attribution.
