---
title: 'R Agent Based Model for Infectious Diesease Tutorial'
subtitle: 
author: "Jasper Zhang"
output:
  html_document: default
  pdf_document: default
---

-   Jasper Zhang, MSc
-   Petros Pechlivanoglou, PhD


Please acknowledge our work. See details to cite below.

\newpage

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval = TRUE)
options(scipen = 999)  # disable scientific notation
rm(list = ls())        # clear memory (removes all the variables from the workspace)
```

Change `eval` to `TRUE` if you want to knit this document.

# 01 Load packages

```{r}
if (!require('pacman')) install.packages('pacman'); library(pacman) 
# load (install if required) packages from CRAN
p_load("devtools", "dplyr", "scales", "ellipse", "ggplot2", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "knitr", "markdown", "stringr", "dampack", "matrixStats")
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) # Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# negate function
`%!in%`                      <- Negate(`%in%`)


# Calculate the infection probability by every cycle, assuming the probability increases by number exposures
fun_infect_prob <- function(p_infect, n_exposure) { 
  # Arguments:
  # p_prob:     the probability of infection in one time contact
  # n_exposure: the time of being exposed to infectious individuals
  # Returns: 
  # the probability of being infected based on certain exposure time
  
  return(1 - (1 - p_infect) ^ (n_exposure))   # 1 - prob is the prob of being safe
}
```


In this basic ABM we assume that individuals can be be in one of 5 states:  1. susceptible to an infection, 2.infected and infectious but not in quarantine, 3.infected in quarantine, 4. recovered. Recovery is assumed to be a saturating state. We assumed that the quarantine period is 14 days from infection for all infected individuals. We further assumed that for the first day of the disease individuals are infectious although asymptomatic, and that as soon as there are symptoms individuals will self-quarantine. We further assumed perfect adherence to quarantine protocols. 
We developed a agent based model where we assumed a daily cycle length. We modelled a hypothetical environment where indiciduals will go to work and can be infected at work and in the community but cannot infect others at home. We used the model to prospectively estimate a 60 day period. We assumed a latency of 4 days from acquiring the infection until symptom development.



# 03 Model input

## 03.1 Define model input parameters

```{r}
## General setups
set.seed(1)                                             # set the seed 

n_cycles                 <- 100                         # number of cycles
n_i                      <- 10000                       # number of individuals

t_iso_max                <- 14                          # quarantine period
t_latent                 <- 4                           # incubation period: time from receiving virus to being infectious
t_detect                 <- 9                           # becoming infectious to isolation
t_recover                <- 14                          # days to recover from being infected


# the 5 health states of the model:
v_names_states           <- c("S",                      # Susceptble 
                              "SQ",                     # Susceptble quarantine 
                              "I",                      # Infected
                              "IQ",                     # Infected quarantine
                              "R")                      # Recovered      

v_names_cycles           <- paste("cycle", 0:n_cycles)  # cycle names
n_states                 <- length(v_names_states)      # number of health states 


#Transition probabilities

#infection probabilities vary by location

# community
p_TransmitCommunity      <- 0.08                        # daily community transmission probability 

# atwork 
p_TransmitWork           <- 0.02                        # daily at work transmission probability per interaction

# Determine the initial number of 'S' (susceptible) and 'I' (infected) agents based on seed ratio
p_seed_ratio             <- 0.3                         # proportion of seed infected agents when initializing the simulation population  
n_S                      <- round((1 - p_seed_ratio) 
                                     * n_i)             # number of initialized susceptible agents
n_I                      <- n_i - n_S                   # number of initialized infected agents


# workplace characteristics 
v_workplace_size         <- c(5, 6, 7)                  # we assume workplaces with sizes of 5 to 7 people


```


# 04 Sample individual level characteristics

## 04.1 Static characteristics

```{r}
# Initialize a population dataframe for an agent-based model

age_mean                 <- 40
age_sd                   <- 10
p_male                   <- 0.5
age_lim                  <- 18

# Create agent matrix
df_X <- data.frame(
  pid = 1:n_i,                                          # Assign individual IDs
  Sex = sample(x = c("Female", "Male"),                 # Random gender assignment
                prob = c(p_male,1 - p_male), 
                size = n_i, replace = TRUE),           
  Age = round(rnorm(n_i,                                # Age drawn from a normal distribution
                    mean = age_mean,
                    sd = age_sd),
              digits = 0)                     
)


# Randomly assign initial states to agents
df_X$state <- sample(c(rep("S", n_S), rep("I", n_I)))

# Ensure Age variable has only  values over a predefined limit
df_X$Age[df_X$Age < age_lim] <- age_lim # only adults

# Define workplace structure and IDs
p_workplace_size <- v_workplace_size / sum(v_workplace_size)
n_workplace <- floor(n_i * p_workplace_size / v_workplace_size)[1]
v_work_id <- c(
  rep(1:n_workplace, each = v_workplace_size[1]),
  rep((n_workplace + 1):(n_workplace  * 2), each = v_workplace_size[2]),
  rep((n_workplace * 2 + 1):(n_workplace * 3), each = v_workplace_size[3])
)


n_remain                 <- n_i - length(v_work_id)
v_more_workid            <- c()
wid_new                  <- max(v_work_id) + 1
while(n_remain !=0){
  n_wid_new  <- ifelse(n_remain > min(v_workplace_size), min(v_workplace_size), n_remain)
  v_more_workid <- c(v_more_workid, rep(wid_new, n_wid_new))
  n_remain <- n_remain - n_wid_new
  wid_new <- wid_new + 1
}


v_work_id                <- sample(c(v_work_id,v_more_workid))
df_X$wid                 <- v_work_id                    # Workplace ID


# Initialize other agent attributes
df_X <- df_X %>%
  mutate(
    n_exposure <-  0,                                     # Exposure level
    n_contact <-  0,                                      # Number of contacts in a day
    v_Ti <-  0,                                           # Time since being infected
    t_iso = 0                                             # Quarantine time clock
  )

# Set the number of contacts at work based on workplace size
n_worksize               <- as.matrix(table(v_work_id))[v_work_id]   # Calculate Workplace size
df_X$n_worksize          <- n_worksize                               # Add Workplace size for each agent
df_X$n_contact           <- sapply(n_worksize,
                                   function(x) sample(0:(x - 1), 1)) # Randomly assign contact number
```


# 05 Define Simulation Functions

## 05.1 Probability function

The `Probs` function updates the transition probabilities of every cycle is shown below.

```{r}
 #M_t                    <- df_X$state     
Probs <- function(df_X, M_t) { 
  # Arguments:
  # df_X: data frame with individual characteristics data 
  # M_t:  health state occupied at cycle t (character variable)
  # Returns: 
  # transition probabilities for that cycle
  
  # create matrix of state transition probabilities
  m_p_t                  <- matrix(0, nrow = n_states, ncol = n_i)
               
  # give the state names to the rows
  rownames(m_p_t)        <- v_names_states                         
  
  #Calculate the probability of being infected for susceptible people
  v_exposure               <- df_X[M_t  == "S",]$n_exposure
  
  p_infect_prob          <- fun_infect_prob(p_TransmitWork, v_exposure)
  
  p_Sus_Inf              <- (1- ((1-  p_TransmitCommunity ) *
                                   (1 - p_infect_prob)))          # p_work_infect  1 minus the prob of being safe all day

  #Calculate the probability of being infected for susceptible quarantine
  
  #susceptible 
  m_p_t["S"     , M_t == "S"]        <- 1 - p_Sus_Inf     # Prob: stay in S state
  m_p_t["I"     , M_t == "S"]        <- p_Sus_Inf         # Prob: transit from S to I
  
  return(m_p_t)
}  


```

## 05.2 Quanrantine Function

```{r}

#Quarantine_Check can update the quarantine clock at current time cycle
Quarantine_Check <- function(df_X, M_t){
  # Arguments:
  # df_X: population dataframe of current time cycle t
  # M_t: states at current cycle t
  # Returns: 
  # new population dataframe with updated states
  
  # -------------------------------------
  # Step1: find people in different quarantine conditions
  # -------------------------------------
  
  # condition 1: find people are going to be released from quarantine
  # check if quarantine clock hit t_iso_max
  
  v_release      <- df_X$t_iso == t_iso_max 
  
    # find susceptible people and infected people who meet quarantine time
  
    v_release_SQ      <- v_release & M_t == "SQ"
    v_release_IQ      <- v_release & M_t == "IQ"
  
  # condition 2: find people who stay in quarantine and the quarantine clock has to be incremented.
   
  v_in_iso <- df_X$t_iso < t_iso_max & df_X$t_iso > 0 & df_X$v_Ti != t_detect
  
  # condition 3: find newly detected people. NOTE: people enter quarantine by detection
  # if agents are already in quarantine "IQ", quarantine clock need to be reset
  
  v_new_detected_in_q                <-  df_X$v_Ti == t_detect & df_X$t_iso > 0
  
  # if agents are in I state "I" and meet the t_detect, all coworkers (except recovered) will be put into quarantine.
  
  v_new_detected_out_q               <-  df_X$v_Ti == t_detect & df_X$t_iso == 0
  
  # find newly infected agents' dependencies in  workpalces
  
  v_new_detected_workplace           <- unique(df_X$wid[v_new_detected_out_q]) #families have newly infected in quarantine cases
  v_new_iso                          <- (df_X$wid %in% v_new_detected_workplace) & M_t != "R"
  
  # find agents' quarantine clock need to be incremented
  v_increment                        <- v_new_iso | v_in_iso
  
  # -------------------------------------
  # Step2: Update quarantine clock
  # -------------------------------------
  
  # release people with meet t_iso_max-days quarantine requirement
  # - isolated susceptible people will go to susceptible
  # - infected people will go to recovered
  
  df_X$t_iso[v_release]              <-   0
  M_t[v_release_SQ]                  <-  "S" #when quarantine ends, state goes back to susceptible
  M_t[v_release_IQ]                  <-  "R" #when quarantine ends, state goes back to recovered
  
  
  # reset agents' quarantine clock if they are detected in quarantine.
  df_X$t_iso[v_new_detected_in_q]  <- 1
  
  # increment one day for all others in qurantine and newly added to quarantine
  
  df_X$t_iso[v_increment]            <- df_X$t_iso[v_increment] + 1 # increment quarantine clock
  M_t[v_new_iso & M_t == "S"]         <- "SQ"
  M_t[v_new_iso & M_t == "I"]         <- "IQ"
  
  return (df_X, M_t) ## need to return both 
}

```

## 05.3 Exposure at work

```{r}

# Exposure_Check calculates the exposure of workers at their workplace
fun_work_exposure <- function(df_X, M_t) {
  
  # Arguments:
  # df_X: population dataframe of current time cycle t
  # M_t: states at current cycle t
  
  # Returns:
  # A modified version of the 'df_X' data frame with updated exposure levels ('expl') and possibly other columns 
  # based on interactions at the workplace.

  
  # -------------------------------------
  # Step1: Initialize and filter worker population
  # -------------------------------------
 
   
  v_atwork <- M_t == "S" | M_t == "I"                                           # Filter workers currently at work
  df_atwork <- df_X[v_atwork,]
  
  v_exposure <- df_X[M_t  == "S",]$n_exposure
  v_infectious <- df_atwork$v_Ti > t_latent
  v_interact_wid <- df_atwork$wid
  
  v_exposure <- df_X[M_t  == "S",]$n_exposure
  v_pid_S    <-    df_X$pid[M_t == "S"]
  
 
  # -------------------------------------
  # Step2: Build the workplace table
  # -------------------------------------
  df_tbl_workplace <- data.frame(table(v_interact_wid))
  
  names(df_tbl_workplace) <- c("wid", "wsize")
  
  
  df_infectious <- df_atwork[v_infectious,]                                       # Filter infectious workers
  v_inf_workplace <- df_infectious$wid                                             # List of workplaces with infectious workers
    
    # Check if there are infectious workers present
    if (nrow(df_infectious) > 0) {
      v_contact <- c()
      
      # -------------------------------------
      # Step3: Identify contacts for infectious workers
      # -------------------------------------
      
      for (i in 1:nrow(df_infectious)) {
        inf_worker_select  <- inf_worker[i,]
        
        v_pid_select <- df_atwork[df_atwork$wid == inf_worker_select$wid,]$pid   # Fetch workers at the same workplace
        v_to_contact <- v_pid_select[-inf_worker_select$pid]                       # Exclude the current worker
        
        # Determine contacts based on the contact number
        if (length(v_to_contact) > 1) {
          new_contact <- sample(v_to_contact, min(length(v_to_contact), inf_worker_select$n_contact))
          v_contact <- c(v_contact, new_contact)
        } else if (length(to_contact) == 1) {
          v_contact <- c(v_contact, to_contact)
        }
      }
  
      
      # -------------------------------------
      # Step4: Build the contact table
      # -------------------------------------
      if (length(v_contact) != 0) {
        df_contact_table <- data.frame(table(v_contact))
        names(df_contact_table) <- c("pid", "n_exposure")
        
        # Convert to numeric types
        df_contact_table$pid <- as.numeric(as.character(df_contact_table$pid))
        df_contact_table$n_exposure <- as.numeric(as.character(df_contact_table$n_exposure))
        
        # Update exposure levels
        v_exposure[df_atwork$pid %in% df_contact_table$pid] <- v_exposure[df_atwork$pid %in% df_contact_table$pid] + contact_table$n_exposure
      }
    }
    
    # Update the main population dataset
    df_X[v_atwork,]$n_exposure <- v_exposure
  }
  
  return(df_X)
}

      
      
      
      
      
      
  


```



## 05.5 Microsimulation function

Below we develop the microsimulation function that allows the model to be run.

```{r}
# `MicroSim` is a microsimulation function to model individual-level disease progression and transmission.
MicroSim <- function(df_X, seed = 1, n_cycles = 10) {
  
  # Arguments:  
  # df_X: A data frame containing individual-level data.
  # seed: Seed for the random number generator; default is 1.
  # n_cycles: Number of cycles or iterations to simulate; default is 10.

  # Ensures reproducibility of results.
  set.seed(seed)

  # Determine the number of individuals in the dataset.
  n_i = nrow(df_X)
  
  # Initialization of matrices to store:
  # m_M: health state information over time for every individual.
  # m_Ti: track the number of days since an individual got infected.
  # m_exposure: track exposure levels for individuals.
  # Each matrix has rows corresponding to individuals and columns corresponding to days.
  
  m_M <- matrix(nrow = n_i, ncol = n_cycles + 1, 
                dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                paste("cycle", 0:n_cycles, sep = " "))) 
  m_Ti <- matrix(nrow = n_i, ncol = n_cycles + 1, 
                  dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                  paste("cycle", 0:n_cycles, sep = " ")))
  m_exposure <- matrix(nrow = n_i, ncol = n_cycles, 
                   dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                   paste("cycle", 1:n_cycles, sep = " ")))

  # Set initial health state and time since illness onset for each individual.
  m_M[, 1] <- df_X$state
  m_Ti[,1] <- df_X$v_Ti
  
  v_Ti <- df_X$v_Ti    
  v_inf <- rep(0, n_i)

  # Initialize vectors to store daily counts of total infections, new infections, and detected cases.
  v_total_inf_daily <- rep(0,n_cycles)
  v_new_inf_daily <- rep(0,n_cycles)
  v_detected_daily <- rep(0,n_cycles)
  
  # Simulation loop for each day.
  for (t in 1:n_cycles) {
    
    # Reset exposure and contact type levels for each individual.
    df_X$n_exposure <- 0

    # Calculate exposure at work for each individual.
    df_X <- work_exposure(df_X)
    m_exposure[,t] <- df_X$n_exposure
    
    # Calculate transition probabilities based on current health state and exposure.
    m_P <- Probs(df_X)

    # Validate transition probabilities.
    check_transition_probability(m_P, verbose = TRUE)
    check_sum_of_transition_array(m_P, n_rows = n_i, n_cycles = n_cycles, verbose = TRUE)
    
    # Generate new health states based on the calculated transition probabilities.
    prob_new_state = samplev(m_P)
    df_X$state = prob_new_state
    df_X = Detection(df_X,v_Ti)
    prob_new_state = df_X$state
    
    # Update vectors with new infection, total infection, and detection counts.
    v_detected_daily[t] =  sum((v_Ti == df_X$t_detect) & prob_new_state != "R")
    v_total_inf_daily[t] = sum(prob_new_state %in% all_infect_states)
    v_new_inf_daily[t] = sum((m_M[, t] %in% sus_states  & prob_new_state %in% all_infect_states ))

    # Update quarantine status based on previous day's state and current state.
    df_X = Quarantine_Check(df_X,m_M[, t])
    qc_state = df_X$state

    # Update the time since illness onset for next day.
    v_Ti <- if_else(qc_state %in% all_infect_states, v_Ti + 1, 0)
    m_Ti[,t + 1] = v_Ti

    # Update individuals who have reached recovery time to 'R' state.
    v_go_to_recover <- if_else(v_Ti >= t_recover, TRUE, FALSE)
    df_X$state[v_go_to_recover] = "R"
    
    # Store current state for each individual for the next day.
    m_M[, t + 1] <- df_X$state

    # Display simulation progress at every 10% completion.
    if(t/(n_cycles/10) == round(t/(n_cycles/10), 0)) {
      cat('\r', paste(t/n_cycles * 100, "% done", sep = " "))
    }
  }

  # Store results from the simulation in a list.
  results <- list(m_M = m_M, pop = df_X, v_new_inf_daily = v_new_inf_daily, 
                  v_total_inf_daily = v_total_inf_daily, v_detected_daily = v_detected_daily)

  # Return the results.
  return(results)

} # End of `MicroSim` function

```

## 06 Run Microsimulation

```{r, eval = TRUE, echo = TRUE, warning = FALSE, message = FALSE, results = FALSE }
# 06 Run Microsimulation
# By specifying all the arguments in the `MicroSim()` the simulation can be started
# Run the simulation model
outcomes <- MicroSim(df_X = df_X, seed = 1,n_cycles = n_cycles)
```

# 07 Visualize results to be updated

```{r}
# First, we'll need the ggplot2 library to create the visualizations.
library(ggplot2)

# -------------------------------------
# Step 1: Data Preparation
# -------------------------------------

# Create a data frame to hold the results for visualization. 
# Here, we take the number of cycles (days) and the respective outcomes for daily new infections, 
# cumulative infections, and daily detections.
df <- data.frame(
  day = 1:n_cycles,                             # Days from 1 to the end of the simulation
  new_inf_daily = outcomes$v_new_inf_daily,     # Daily new infections
  total_inf_daily = outcomes$v_total_inf_daily, # Cumulative daily infections
  detected_daily = outcomes$v_detected_daily    # Daily detected cases
)

# -------------------------------------
# Step 2: Data Visualization
# -------------------------------------

# Using ggplot, we'll plot the daily new infections, cumulative infections, and detected cases.
p <- ggplot(df, aes(x = day)) +                 # Define the x-axis as the 'day'

  # Plot daily new infections
  geom_line(aes(y = new_inf_daily, color = "New Infections Daily"), size = 1) +

  # Plot cumulative infections
  geom_line(aes(y = total_inf_daily, color = "Total Infections Daily"), size = 1) +

  # Plot daily detected cases
  geom_line(aes(y = detected_daily, color = "Detected Daily"), size = 1) +

  # Add labels and title to the plot
  labs(
    title = paste0("Daily Cases Over ",n_cycles," Days"),       # Title of the plot
    x = "Day",                                 # Label for the x-axis
    y = "Number of Cases",                      # Label for the y-axis
    color = "Legend"                            # Legend title
  ) +

  # Customize the colors for each line in the plot
  scale_color_manual(values = c("New Infections Daily" = "blue", 
                                "Total Infections Daily" = "darkgreen",
                                "Detected Daily" = "red")) +

  # Use a minimal theme for a clean look
  theme_minimal() +

  # Position the legend at the bottom of the plot
  theme(legend.position = "bottom")

# Display the generated plot
p

# -------------------------------------
# Step 3: Save the Visualization
# -------------------------------------

# Save the plot as a PNG image. The DPI determines the resolution, and width and height determine the size.
ggsave("daily_cases_plot.png", p, dpi = 300, width = 10, height = 8, units = "in", device = "png")

```


We kindly request you to add the following Acknowledgement paragraph to your further work where DARTH code formed the basis. We also like to remind you that you can add other sources of reference to this paragraph to acknowledge code you got from others.

# Acknowlegdement

For this work we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention: Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 1329--1339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

Other work from DARTH can be found on the website: <http://darthworkgroup.com/publications/>

# Copyright for assignment work

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.All rights reserved in Canada, the United States and worldwide. Copyright, trademarks, trade names and any and all associated intellectual property are exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating institutions. These materials may be used, reproduced, modified, distributed and adapted with proper attribution.
